<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é»çš„è®Šæ›å­¸ç¿’å·¥å…·</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #4361ee;
            --primary-hover: #3a53d0;
            --secondary-color: #3f37c9;
            --accent-color: #4cc9f0;
            --danger-color: #ef476f;
            --success-color: #06d6a0;
            --bg-color: #f8f9fa;
            --card-bg: #ffffff;
            --text-main: #2b2d42;
            --text-light: #8d99ae;
            --border-radius: 12px;
            --shadow-sm: 0 2px 8px rgba(0,0,0,0.05);
            --shadow-md: 0 8px 24px rgba(0,0,0,0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Noto Sans TC', 'Microsoft JhengHei', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            min-height: 100vh;
            padding: 20px;
            display: flex;
            justify-content: center;
        }
        
        .container {
            width: 100%;
            max-width: 1400px;
            background: transparent;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        /* Header Styling */
        .header {
            background: var(--card-bg);
            padding: 25px 40px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-left: 6px solid var(--primary-color);
        }
        
        .header-content h1 {
            font-size: 1.8rem;
            color: var(--text-main);
            margin-bottom: 5px;
            font-weight: 700;
        }
        
        .header-content p {
            color: var(--text-light);
            font-size: 1rem;
        }

        /* Layout Grid */
        .main-content {
            display: grid;
            grid-template-columns: 380px 1fr; /* å›ºå®šå·¦å´å¯¬åº¦ï¼Œå³å´è‡ªé©æ‡‰ */
            gap: 25px;
            align-items: start;
        }
        
        /* Left Sidebar (Controls) */
        .controls {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .section {
            background: var(--card-bg);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-sm);
            transition: transform 0.2s;
        }
        
        .section h3 {
            color: var(--text-main);
            margin-bottom: 20px;
            font-size: 1.1rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .section h3::before {
            content: '';
            display: block;
            width: 4px;
            height: 18px;
            background: var(--primary-color);
            border-radius: 2px;
        }
        
        /* Input Styling */
        .input-group {
            margin-bottom: 15px;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-main);
        }
        
        .input-group input, .input-group select {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            font-size: 0.95rem;
            background: #fdfdfd;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(67, 97, 238, 0.15);
        }
        
        /* Custom Input Grid for Coordinates */
        .coordinate-inputs {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .coordinate-inputs .full-width {
            grid-column: 1 / -1;
        }
        
        /* Button Styling */
        .btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.2s;
            width: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
        }
        
        .btn:hover {
            background-color: var(--primary-hover);
            transform: translateY(-1px);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn-secondary {
            background-color: #e2e6ea;
            color: var(--text-main);
        }
        .btn-secondary:hover {
            background-color: #dbe0e6;
        }
        
        .btn-danger {
            background-color: #ffe5e9;
            color: var(--danger-color);
        }
        .btn-danger:hover {
            background-color: #ffd1d7;
        }
        
        .btn-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        /* Right Content (Canvas) */
        .coordinate-plane {
            background: var(--card-bg);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow-md);
            padding: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            min-height: 660px; /* ç¢ºä¿é«˜åº¦ */
        }
        
        #canvas {
            border-radius: 4px;
            /* è®“ Canvas åœ¨å°è¢å¹•ä¸‹è‡ªé©æ‡‰ */
            max-width: 100%;
            height: auto;
            box-shadow: 0 0 0 1px #eee; /* å¾®å¦™çš„é‚Šæ¡† */
        }
        
        /* Points List */
        .points-list {
            max-height: 250px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 5px;
            background: #fafafa;
            margin-bottom: 15px;
        }

        /* Custom Scrollbar */
        .points-list::-webkit-scrollbar {
            width: 6px;
        }
        .points-list::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        .points-list::-webkit-scrollbar-thumb {
            background: #ccc;
            border-radius: 3px;
        }
        
        .point-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: white;
            border-radius: 6px;
            border: 1px solid transparent;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .point-item:hover {
            border-color: #ddd;
            transform: translateX(2px);
        }
        
        .point-item.selected {
            background: #eef2ff;
            border: 1px solid var(--primary-color);
            border-left: 4px solid var(--primary-color);
        }
        
        .point-item span strong {
            color: var(--primary-color);
            font-size: 1.1em;
            margin-right: 5px;
        }

        .delete-btn {
            background: transparent;
            color: #999;
            border: none;
            padding: 5px;
            cursor: pointer;
            transition: color 0.2s;
            font-size: 0.9rem;
        }
        .delete-btn:hover {
            color: var(--danger-color);
        }
        
        /* Modern Radio Buttons (Segmented Controls) */
        .radio-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }
        
        .radio-item {
            position: relative;
            flex: 1;
            min-width: 80px;
        }
        
        .radio-item input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .radio-item span {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: #f1f3f5;
            border: 1px solid transparent;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
            color: #555;
            font-weight: 500;
        }
        
        .radio-item input[type="radio"]:checked + span {
            background: var(--primary-color);
            color: white;
            box-shadow: 0 4px 10px rgba(67, 97, 238, 0.3);
        }
        
        .radio-item:hover span {
            background: #e9ecef;
        }
        .radio-item input[type="radio"]:checked:hover span {
            background: var(--primary-hover);
        }

        .transformation-options {
            display: none;
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid #eee;
            animation: slideDown 0.3s ease;
        }
        
        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .transformation-options.active {
            display: block;
        }
        
        /* Alerts */
        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: 500;
            display: none;
            font-size: 0.95rem;
            box-shadow: var(--shadow-sm);
        }
        
        .alert.show {
            display: flex;
            align-items: center;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        .alert-error {
            background: #fff5f5;
            border-left: 4px solid var(--danger-color);
            color: #c53030;
        }
        
        .alert-success {
            background: #f0fff4;
            border-left: 4px solid var(--success-color);
            color: #276749;
        }
        
        .alert-warning {
            background: #fffaf0;
            border-left: 4px solid #ed8936;
            color: #c05621;
        }
        
        @media (max-width: 1000px) {
            .main-content {
                grid-template-columns: 1fr;
            }
            .coordinate-plane {
                order: -1; /* åœ¨å°è¢å¹•æ™‚ï¼Œç•«å¸ƒé¡¯ç¤ºåœ¨æ§åˆ¶é …ä¸Šæ–¹ */
                min-height: auto;
            }
            .header-content h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-content">
                <h1>ğŸ¯ åœ¨ç›´è§’åæ¨™å¹³é¢ä¸Šé»çš„è®Šæ›</h1>
                <p>äº’å‹•å¼å­¸ç¿’ï¼šå¹³ç§»ã€åå°„èˆ‡æ—‹è½‰</p>
            </div>
        </div>
        
        <div class="main-content">
            <div class="controls">
                <div class="alert alert-error" id="alertMessage"></div>
                
                <div class="section">
                    <h3>ğŸ“ æ·»åŠ æ–°é»</h3>
                    <div class="coordinate-inputs">
                        <div class="input-group">
                            <label>X åæ¨™</label>
                            <input type="number" id="xCoord" value="2" min="-9" max="9" placeholder="X">
                        </div>
                        <div class="input-group">
                            <label>Y åæ¨™</label>
                            <input type="number" id="yCoord" value="-3" min="-9" max="9" placeholder="Y">
                        </div>
                        <div class="input-group full-width">
                            <label>é»æ¨™ç±¤ (ä¾‹å¦‚: A)</label>
                            <input type="text" id="pointLabel" value="A" maxlength="2" placeholder="æ¨™ç±¤">
                        </div>
                    </div>
                    <div class="btn-group">
                        <button class="btn" onclick="addPoint()">æ·»åŠ é»</button>
                        <button class="btn btn-secondary" onclick="generateRandomPoint()">éš¨æ©Ÿç”Ÿæˆ</button>
                    </div>
                </div>

                <div class="section">
                    <h3>ğŸ“‹ é»åˆ—è¡¨èˆ‡ç®¡ç†</h3>
                    <p style="font-size: 0.85rem; color: #666; margin-bottom: 10px;">é»æ“Šåˆ—è¡¨ä¸­çš„é»ä»¥é¸å–ï¼Œé¸å–å¾Œå¯é€²è¡Œè®Šæ›ã€‚</p>
                    <div class="points-list" id="pointsList">
                        <p style="text-align: center; color: #999; padding: 20px;">æš«ç„¡é»ï¼Œè«‹ä¸Šæ–¹æ·»åŠ ä¸€å€‹é»</p>
                    </div>
                    <button class="btn btn-danger" style="margin-top: 10px;" onclick="clearAllPoints()">æ¸…é™¤æ‰€æœ‰é»</button>
                </div>
                
                <div class="section">
                    <h3>ğŸ”„ è®Šæ›æ“ä½œ</h3>
                    <div class="input-group">
                        <label>é¸æ“‡è®Šæ›é¡å‹</label>
                        <select id="transformationType" onchange="showTransformationOptions()">
                            <option value="">-- è«‹é¸æ“‡ --</option>
                            <option value="translation">å¹³ç§» (Translation)</option>
                            <option value="reflection">åå°„ (Reflection)</option>
                            <option value="rotation">æ—‹è½‰ (Rotation)</option>
                        </select>
                    </div>
                    
                    <div id="translationOptions" class="transformation-options">
                        <div class="option-group">
                            <label style="font-weight:600; font-size:0.9rem; margin-bottom:5px; display:block;">æ–¹å‘ï¼š</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="translation" value="up">
                                    <span>â¬†ï¸ å‘ä¸Š</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="translation" value="down">
                                    <span>â¬‡ï¸ å‘ä¸‹</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="translation" value="left">
                                    <span>â¬…ï¸ å‘å·¦</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="translation" value="right">
                                    <span>â¡ï¸ å‘å³</span>
                                </label>
                            </div>
                            <div class="input-group" style="margin-top: 15px;">
                                <label>ç§»å‹•å–®ä½æ•¸ï¼š</label>
                                <input type="number" id="translationUnits" value="3" min="1" max="10">
                            </div>
                        </div>
                    </div>
                    
                    <div id="reflectionOptions" class="transformation-options">
                        <div class="option-group">
                            <label style="font-weight:600; font-size:0.9rem; margin-bottom:5px; display:block;">åå°„è»¸ï¼š</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="reflection" value="x-axis">
                                    <span>æ²¿ X è»¸</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="reflection" value="y-axis">
                                    <span>æ²¿ Y è»¸</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <div id="rotationOptions" class="transformation-options">
                        <div class="option-group">
                            <label style="font-weight:600; font-size:0.9rem; margin-bottom:5px; display:block;">æ–¹å‘ï¼š</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="rotationDirection" value="clockwise">
                                    <span>â†» é †æ™‚é‡</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="rotationDirection" value="counterclockwise">
                                    <span>â†º é€†æ™‚é‡</span>
                                </label>
                            </div>
                            
                            <label style="font-weight:600; font-size:0.9rem; margin:15px 0 5px 0; display:block;">è§’åº¦ (ç¹åŸé»)ï¼š</label>
                            <div class="radio-group">
                                <label class="radio-item">
                                    <input type="radio" name="rotationAngle" value="90">
                                    <span>90Â°</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="rotationAngle" value="180">
                                    <span>180Â°</span>
                                </label>
                                <label class="radio-item">
                                    <input type="radio" name="rotationAngle" value="270">
                                    <span>270Â°</span>
                                </label>
                            </div>
                        </div>
                    </div>
                    
                    <button class="btn" style="margin-top: 20px;" onclick="applyTransformation()">
                        <span>ğŸš€ åŸ·è¡Œè®Šæ›å‹•ç•«</span>
                    </button>
                </div>
            </div>
            
            <div class="coordinate-plane">
                <canvas id="canvas" width="600" height="600"></canvas>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const points = [];
        let selectedPointIndex = -1;
        let animationId = null;
        
        // åˆå§‹åŒ–ç•«å¸ƒ
        function initCanvas() {
            drawGrid();
            drawAxes();
            drawPoints();
        }
        
        // ç¹ªè£½ç¶²æ ¼
        function drawGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // è®“èƒŒæ™¯è®Šç™½
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0,0,canvas.width, canvas.height);

            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 1;
            
            const gridSize = 30;
            for (let i = 0; i <= canvas.width; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(i, 0);
                ctx.lineTo(i, canvas.height);
                ctx.stroke();
            }
            
            for (let i = 0; i <= canvas.height; i += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }
        }
        
        // ç¹ªè£½åæ¨™è»¸
        function drawAxes() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            
            // Xè»¸
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(canvas.width - 10, centerY);
            ctx.stroke();
            
            // Yè»¸
            ctx.beginPath();
            ctx.moveTo(centerX, canvas.height);
            ctx.lineTo(centerX, 10);
            ctx.stroke();
            
            // ç¹ªè£½åˆ»åº¦å’Œæ•¸å­—
            ctx.fillStyle = '#666';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            const gridSize = 30;
            for (let i = -9; i <= 9; i++) {
                if (i !== 0) {
                    const x = centerX + i * gridSize;
                    const y = centerY + i * gridSize;
                    
                    // Xè»¸åˆ»åº¦
                    if (x >= 0 && x <= canvas.width) {
                        ctx.fillText(i.toString(), x, centerY + 15);
                    }
                    
                    // Yè»¸åˆ»åº¦
                    if (y >= 0 && y <= canvas.height) {
                        ctx.fillText((-i).toString(), centerX - 15, y + 4);
                    }
                }
            }
            
            // åŸé»
            ctx.fillText('O', centerX - 10, centerY + 15);
            
            // æ·»åŠ åæ¨™è»¸æ¨™ç±¤
            ctx.fillStyle = '#333';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            
            // Xè»¸æ¨™ç±¤
            ctx.fillText('x', canvas.width - 20, centerY - 10);
            
            // Yè»¸æ¨™ç±¤
            ctx.fillText('y', centerX + 15, 20);
            
            // ç¹ªè£½ç®­é ­
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.fillStyle = '#333';
            
            // Xè»¸ç®­é ­
            ctx.beginPath();
            ctx.moveTo(canvas.width - 10, centerY);
            ctx.lineTo(canvas.width - 20, centerY - 5);
            ctx.lineTo(canvas.width - 20, centerY + 5);
            ctx.closePath();
            ctx.fill();
            
            // Yè»¸ç®­é ­
            ctx.beginPath();
            ctx.moveTo(centerX, 10);
            ctx.lineTo(centerX - 5, 20);
            ctx.lineTo(centerX + 5, 20);
            ctx.closePath();
            ctx.fill();
        }
        
        // åæ¨™è½‰æ›
        function coordToPixel(x, y) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gridSize = 30;
            return {
                x: centerX + x * gridSize,
                y: centerY - y * gridSize
            };
        }
        
        function pixelToCoord(px, py) {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const gridSize = 30;
            return {
                x: Math.round((px - centerX) / gridSize),
                y: Math.round((centerY - py) / gridSize)
            };
        }
        
        // ç¹ªè£½é»
        function drawPoints() {
            points.forEach((point, index) => {
                const pixel = coordToPixel(point.x, point.y);
                
                // ç¹ªè£½é»ï¼ˆäº¤å‰ç¬¦è™Ÿï¼‰
                // ä¿®æ”¹äº†é¡è‰²ï¼Œä½¿å…¶æ›´ç¬¦åˆæ–°ä¸»é¡Œ
                ctx.strokeStyle = index === selectedPointIndex ? '#ef476f' : '#4361ee';
                ctx.lineWidth = 3;
                const crossSize = 8;
                
                ctx.beginPath();
                ctx.moveTo(pixel.x - crossSize, pixel.y - crossSize);
                ctx.lineTo(pixel.x + crossSize, pixel.y + crossSize);
                ctx.moveTo(pixel.x + crossSize, pixel.y - crossSize);
                ctx.lineTo(pixel.x - crossSize, pixel.y + crossSize);
                ctx.stroke();
                
                // ç¹ªè£½åˆä½µçš„æ¨™ç±¤å’Œåæ¨™
                ctx.fillStyle = '#2b2d42';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${point.label}(${point.x}, ${point.y})`, pixel.x, pixel.y + 25);
            });
        }
        
        // é¡¯ç¤ºæç¤ºè¨Šæ¯
        function showAlert(message, type = 'error') {
            const alertElement = document.getElementById('alertMessage');
            alertElement.textContent = message;
            alertElement.className = `alert alert-${type} show`;
            
            // 3ç§’å¾Œè‡ªå‹•éš±è—
            setTimeout(() => {
                alertElement.classList.remove('show');
            }, 3000);
        }
        
        // æ·»åŠ é»
        function addPoint() {
            const x = parseInt(document.getElementById('xCoord').value);
            const y = parseInt(document.getElementById('yCoord').value);
            const label = document.getElementById('pointLabel').value.trim().toUpperCase();
            
            if (!label) {
                showAlert('è«‹è¼¸å…¥é»æ¨™ç±¤ï¼');
                return;
            }
            
            // æª¢æŸ¥æ¨™ç±¤æ˜¯å¦å·²å­˜åœ¨
            if (points.some(point => point.label === label)) {
                showAlert('æ¨™ç±¤å·²å­˜åœ¨ï¼Œè«‹ä½¿ç”¨ä¸åŒçš„æ¨™ç±¤ï¼');
                return;
            }
            
            if (x < -9 || x > 9 || y < -9 || y > 9) {
                showAlert('åæ¨™å¿…é ˆåœ¨ -9 åˆ° 9 ä¹‹é–“ï¼');
                return;
            }
            
            points.push({ x, y, label });
            updatePointsList();
            initCanvas();
            showAlert(`æˆåŠŸæ·»åŠ é» ${label}(${x}, ${y})ï¼`, 'success');
            
            // è‡ªå‹•ç”Ÿæˆä¸‹ä¸€å€‹æ¨™ç±¤
            const nextLabel = String.fromCharCode(label.charCodeAt(0) + 1);
            if (nextLabel <= 'Z') {
                document.getElementById('pointLabel').value = nextLabel;
            }
        }
        
        // ç”Ÿæˆéš¨æ©Ÿé»
        function generateRandomPoint() {
            const x = Math.floor(Math.random() * 19) - 9;
            const y = Math.floor(Math.random() * 19) - 9;
            
            document.getElementById('xCoord').value = x;
            document.getElementById('yCoord').value = y;
            
            // æ‰¾åˆ°å¯ç”¨çš„æ¨™ç±¤
            let label = 'A';
            while (points.some(point => point.label === label) && label <= 'Z') {
                label = String.fromCharCode(label.charCodeAt(0) + 1);
            }
            document.getElementById('pointLabel').value = label;
        }
        
        // æ›´æ–°é»åˆ—è¡¨
        function updatePointsList() {
            const pointsList = document.getElementById('pointsList');
            
            if (points.length === 0) {
                pointsList.innerHTML = '<p style="text-align: center; color: #999; padding: 20px;">æš«ç„¡é»ï¼Œè«‹ä¸Šæ–¹æ·»åŠ ä¸€å€‹é»</p>';
                return;
            }
            
            pointsList.innerHTML = points.map((point, index) => `
                <div class="point-item ${index === selectedPointIndex ? 'selected' : ''}" onclick="selectPoint(${index})">
                    <span><strong>${point.label}</strong> (${point.x}, ${point.y})</span>
                    <button class="delete-btn" onclick="removePoint(${index}); event.stopPropagation();" title="åˆªé™¤">âœ• åˆªé™¤</button>
                </div>
            `).join('');
        }
        
        // é¸æ“‡é»
        function selectPoint(index) {
            selectedPointIndex = index;
            updatePointsList();
            initCanvas();
        }
        
        // åˆªé™¤é»
        function removePoint(index) {
            points.splice(index, 1);
            if (selectedPointIndex === index) {
                selectedPointIndex = -1;
            } else if (selectedPointIndex > index) {
                selectedPointIndex--;
            }
            updatePointsList();
            initCanvas();
        }
        
        // æ¸…é™¤æ‰€æœ‰é»
        function clearAllPoints() {
            if (points.length === 0) {
                showAlert('æ²’æœ‰é»å¯ä»¥æ¸…é™¤ï¼', 'warning');
                return;
            }
            
            points.length = 0;
            selectedPointIndex = -1;
            updatePointsList();
            initCanvas();
            showAlert('å·²æ¸…é™¤æ‰€æœ‰é»ï¼', 'success');
        }
        
        // é¡¯ç¤ºè®Šæ›é¸é …
        function showTransformationOptions() {
            const type = document.getElementById('transformationType').value;
            
            // éš±è—æ‰€æœ‰é¸é …
            document.querySelectorAll('.transformation-options').forEach(el => {
                el.classList.remove('active');
            });
            
            // é¡¯ç¤ºå°æ‡‰é¸é …
            if (type) {
                document.getElementById(type + 'Options').classList.add('active');
            }
        }
        
        // åŸ·è¡Œè®Šæ›
        function applyTransformation() {
            if (selectedPointIndex === -1) {
                showAlert('è«‹å…ˆé¸æ“‡ä¸€å€‹é»ï¼');
                return;
            }
            
            const type = document.getElementById('transformationType').value;
            if (!type) {
                showAlert('è«‹é¸æ“‡è®Šæ›é¡å‹ï¼');
                return;
            }
            
            const point = points[selectedPointIndex];
            let newPoint = null;
            let transformationText = '';
            
            switch (type) {
                case 'translation':
                    newPoint = applyTranslation(point);
                    break;
                case 'reflection':
                    newPoint = applyReflection(point);
                    break;
                case 'rotation':
                    newPoint = applyRotation(point);
                    break;
            }
            
            if (newPoint) {
                animateTransformation(point, newPoint, type);
            }
        }
        
        // å¹³ç§»è®Šæ›
        function applyTranslation(point) {
            const direction = document.querySelector('input[name="translation"]:checked');
            const units = parseInt(document.getElementById('translationUnits').value);
            
            if (!direction) {
                showAlert('è«‹é¸æ“‡å¹³ç§»æ–¹å‘ï¼');
                return null;
            }
            
            let newX = point.x;
            let newY = point.y;
            let directionText = '';
            
            switch (direction.value) {
                case 'up':
                    newY += units;
                    directionText = `å‘ä¸Šå¹³ç§» ${units} å–®ä½`;
                    break;
                case 'down':
                    newY -= units;
                    directionText = `å‘ä¸‹å¹³ç§» ${units} å–®ä½`;
                    break;
                case 'left':
                    newX -= units;
                    directionText = `å‘å·¦å¹³ç§» ${units} å–®ä½`;
                    break;
                case 'right':
                    newX += units;
                    directionText = `å‘å³å¹³ç§» ${units} å–®ä½`;
                    break;
            }
            
            if (newX < -9 || newX > 9 || newY < -9 || newY > 9) {
                showAlert('è®Šæ›å¾Œçš„é»è¶…å‡ºåæ¨™ç¯„åœï¼');
                return null;
            }
            
            return { x: newX, y: newY, label: point.label + "'" };
        }
        
        // åå°„è®Šæ›
        function applyReflection(point) {
            const axis = document.querySelector('input[name="reflection"]:checked');
            
            if (!axis) {
                showAlert('è«‹é¸æ“‡åå°„è»¸ï¼');
                return null;
            }
            
            let newX = point.x;
            let newY = point.y;
            let axisText = '';
            
            switch (axis.value) {
                case 'x-axis':
                    newY = -point.y;
                    axisText = 'æ²¿ X è»¸åå°„';
                    break;
                case 'y-axis':
                    newX = -point.x;
                    axisText = 'æ²¿ Y è»¸åå°„';
                    break;
            }
            
            return { x: newX, y: newY, label: point.label + "'" };
        }
        
        // æ—‹è½‰è®Šæ›
        function applyRotation(point) {
            const direction = document.querySelector('input[name="rotationDirection"]:checked');
            const angle = document.querySelector('input[name="rotationAngle"]:checked');
            
            if (!direction || !angle) {
                showAlert('è«‹é¸æ“‡æ—‹è½‰æ–¹å‘å’Œè§’åº¦ï¼');
                return null;
            }
            
            let newX, newY;
            const angleValue = parseInt(angle.value);
            const isClockwise = direction.value === 'clockwise';
            
            // è¨ˆç®—æ—‹è½‰å¾Œçš„åæ¨™
            const radians = (isClockwise ? -angleValue : angleValue) * Math.PI / 180;
            newX = Math.round(point.x * Math.cos(radians) - point.y * Math.sin(radians));
            newY = Math.round(point.x * Math.sin(radians) + point.y * Math.cos(radians));
            
            const directionText = isClockwise ? 'é †æ™‚é‡' : 'é€†æ™‚é‡';
            
            return { x: newX, y: newY, label: point.label + "'" };
        }
        
        // å‹•ç•«è®Šæ›
        function animateTransformation(originalPoint, newPoint, transformationType) {
            // æ ¹æ“šè®Šæ›é¡å‹è¨­å®šä¸åŒçš„å‹•ç•«æ­¥æ•¸
            let steps;
            if (transformationType === 'translation') {
                steps = 120; // å¹³ç§»ï¼šå¢åŠ 2ç§’ (60fps * 2ç§’ = 120æ­¥)
            } else {
                steps = 180; // åå°„å’Œæ—‹è½‰ï¼šå¢åŠ 3ç§’ (60fps * 3ç§’ = 180æ­¥)
            }
            let currentStep = 0;
            
            function animate() {
                if (currentStep <= steps) {
                    // é‡ç¹ªç•«å¸ƒ
                    initCanvas();
                    
                    if (transformationType === 'rotation') {
                        animateRotation(originalPoint, newPoint, currentStep, steps);
                    } else if (transformationType === 'reflection') {
                        animateReflection(originalPoint, newPoint, currentStep, steps);
                    } else {
                        animateTranslation(originalPoint, newPoint, currentStep, steps);
                    }
                    
                    currentStep++;
                    animationId = requestAnimationFrame(animate);
                } else {
                    // å‹•ç•«çµæŸï¼Œæ·»åŠ æ–°é»
                    const newLabel = newPoint.label;
                    let finalLabel = newLabel;
                    let counter = 1;
                    
                    // ç¢ºä¿æ¨™ç±¤å”¯ä¸€
                    while (points.some(p => p.label === finalLabel)) {
                        finalLabel = newLabel.replace("'", '') + "'" + counter;
                        counter++;
                    }
                    
                    points.push({ x: newPoint.x, y: newPoint.y, label: finalLabel });
                    updatePointsList();
                    
                    // å¦‚æœæ˜¯åå°„å‹•ç•«ï¼Œé¡¯ç¤ºåƒè€ƒç·šæ®µä¸¦é€æ¼¸æ·¡å‡º
                    if (transformationType === 'reflection') {
                        showReflectionLinesWithFadeOut(originalPoint, newPoint);
                    } else {
                        initCanvas();
                    }
                }
            }
            
            animate();
        }
        
        // å¹³ç§»å‹•ç•«
        function animateTranslation(originalPoint, newPoint, currentStep, totalSteps) {
            const deltaX = (newPoint.x - originalPoint.x) / totalSteps;
            const deltaY = (newPoint.y - originalPoint.y) / totalSteps;
            
            const currentX = originalPoint.x + deltaX * currentStep;
            const currentY = originalPoint.y + deltaY * currentStep;
            
            // ç¹ªè£½å‹•ç•«ä¸­çš„é»ï¼ˆäº¤å‰ç¬¦è™Ÿï¼‰
            const pixel = coordToPixel(currentX, currentY);
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            const crossSize = 10;
            
            ctx.beginPath();
            ctx.moveTo(pixel.x - crossSize, pixel.y - crossSize);
            ctx.lineTo(pixel.x + crossSize, pixel.y + crossSize);
            ctx.moveTo(pixel.x + crossSize, pixel.y - crossSize);
            ctx.lineTo(pixel.x - crossSize, pixel.y + crossSize);
            ctx.stroke();
            
            // ç¹ªè£½è»Œè·¡
            if (currentStep > 0) {
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                const startPixel = coordToPixel(originalPoint.x, originalPoint.y);
                ctx.moveTo(startPixel.x, startPixel.y);
                ctx.lineTo(pixel.x, pixel.y);
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
        
        // æ—‹è½‰å‹•ç•«ï¼ˆåœ“å¼§è»Œè·¡ï¼‰
        function animateRotation(originalPoint, newPoint, currentStep, totalSteps) {
            const centerX = 0; // ç¹åŸé»æ—‹è½‰
            const centerY = 0;
            
            // ç²å–ç”¨æˆ¶é¸æ“‡çš„æ—‹è½‰åƒæ•¸
            const direction = document.querySelector('input[name="rotationDirection"]:checked');
            const angle = document.querySelector('input[name="rotationAngle"]:checked');
            const targetAngle = parseInt(angle.value);
            const isClockwise = direction.value === 'clockwise';
            
            // è¨ˆç®—åŸé»åˆ°èµ·å§‹é»çš„è·é›¢å’Œè§’åº¦
            const radius = Math.sqrt(originalPoint.x * originalPoint.x + originalPoint.y * originalPoint.y);
            const startAngle = Math.atan2(originalPoint.y, originalPoint.x);
            
            // æ ¹æ“šç”¨æˆ¶é¸æ“‡è¨ˆç®—å¯¦éš›çš„è§’åº¦è®ŠåŒ–
            let totalRotationRadians = targetAngle * Math.PI / 180;
            if (isClockwise) {
                totalRotationRadians = -totalRotationRadians;
            }
            
            // è¨ˆç®—ç•¶å‰è§’åº¦
            const currentRotationRadians = (totalRotationRadians * currentStep) / totalSteps;
            const currentAngle = startAngle + currentRotationRadians;
            
            const currentX = centerX + radius * Math.cos(currentAngle);
            const currentY = centerY + radius * Math.sin(currentAngle);
            
            // ç¹ªè£½å‹•ç•«ä¸­çš„é»ï¼ˆäº¤å‰ç¬¦è™Ÿï¼‰
            const pixel = coordToPixel(currentX, currentY);
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            const crossSize = 10;
            
            ctx.beginPath();
            ctx.moveTo(pixel.x - crossSize, pixel.y - crossSize);
            ctx.lineTo(pixel.x + crossSize, pixel.y + crossSize);
            ctx.moveTo(pixel.x + crossSize, pixel.y - crossSize);
            ctx.lineTo(pixel.x - crossSize, pixel.y + crossSize);
            ctx.stroke();
            
            // ç¹ªè£½åœ“å¼§è»Œè·¡
            if (currentStep > 0) {
                const centerPixel = coordToPixel(centerX, centerY);
                const radiusPixel = radius * 30; // 30æ˜¯gridSize
                
                ctx.strokeStyle = '#ff6b6b';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.arc(centerPixel.x, centerPixel.y, radiusPixel, -startAngle, -currentAngle, isClockwise);
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // ç¹ªè£½è§’åº¦é¡¯ç¤º
            drawAngleDisplay(centerX, centerY, startAngle, currentAngle, radius, targetAngle, isClockwise);
        }
        
        // ç¹ªè£½è§’åº¦é¡¯ç¤º
        function drawAngleDisplay(centerX, centerY, startAngle, currentAngle, radius, targetAngle, isClockwise) {
            const centerPixel = coordToPixel(centerX, centerY);
            const displayRadius = Math.min(60, radius * 15); // è§’åº¦å¼§çš„é¡¯ç¤ºåŠå¾‘
            
            // è¨ˆç®—ç•¶å‰æ—‹è½‰çš„è§’åº¦ï¼ˆä»¥åº¦ç‚ºå–®ä½ï¼‰- å¾0é–‹å§‹ç´¯ç©
            let rotatedAngle = Math.abs(currentAngle - startAngle) * 180 / Math.PI;
            rotatedAngle = Math.round(rotatedAngle);
            
            // ç¹ªè£½è§’åº¦å¼§ç·š - å¾èµ·å§‹è§’åº¦é–‹å§‹ï¼Œå¼§ç·šé•·åº¦æ ¹æ“šç•¶å‰é€²åº¦
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 4;
            ctx.setLineDash([]);
            ctx.beginPath();
            
            // å¾èµ·å§‹è§’åº¦ç•«å¼§åˆ°ç•¶å‰è§’åº¦
            ctx.arc(centerPixel.x, centerPixel.y, displayRadius, -startAngle, -currentAngle, !isClockwise);
            ctx.stroke();
            
            // ç¹ªè£½èµ·å§‹ç·šï¼ˆå¾ä¸­å¿ƒåˆ°èµ·å§‹é»æ–¹å‘ï¼‰
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerPixel.x, centerPixel.y);
            ctx.lineTo(
                centerPixel.x + displayRadius * Math.cos(startAngle),
                centerPixel.y - displayRadius * Math.sin(startAngle)
            );
            ctx.stroke();
            
            // ç¹ªè£½ç•¶å‰ç·šï¼ˆå¾ä¸­å¿ƒåˆ°ç•¶å‰é»æ–¹å‘ï¼‰
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(centerPixel.x, centerPixel.y);
            ctx.lineTo(
                centerPixel.x + displayRadius * Math.cos(currentAngle),
                centerPixel.y - displayRadius * Math.sin(currentAngle)
            );
            ctx.stroke();
            
            // è¨ˆç®—å¼§ç·šä¸­é»ä½ç½®ä¾†æ”¾ç½®è§’åº¦æ–‡å­—
            const midAngle = startAngle + (currentAngle - startAngle) / 2;
            const textRadius = displayRadius + 25;
            const textX = centerPixel.x + textRadius * Math.cos(midAngle);
            const textY = centerPixel.y - textRadius * Math.sin(midAngle);
            
            // è§’åº¦æ–‡å­—èƒŒæ™¯
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = '#ff9800';
            ctx.lineWidth = 2;
            const textWidth = ctx.measureText(`${rotatedAngle}Â°`).width + 20;
            const textHeight = 25;
            
            ctx.fillRect(textX - textWidth/2, textY - textHeight/2, textWidth, textHeight);
            ctx.strokeRect(textX - textWidth/2, textY - textHeight/2, textWidth, textHeight);
            
            // è§’åº¦æ–‡å­—
            ctx.fillStyle = '#ff9800';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${rotatedAngle}Â°`, textX, textY);
        }
        
        // åå°„å‹•ç•«
        function animateReflection(originalPoint, newPoint, currentStep, totalSteps) {
            const halfSteps = totalSteps / 2;
            
            if (currentStep <= halfSteps) {
                // ç¬¬ä¸€éšæ®µï¼šå¾åŸé»ç•«ç·šåˆ°åå°„è»¸
                animateReflectionFirstPhase(originalPoint, newPoint, currentStep, halfSteps);
            } else {
                // ç¬¬äºŒéšæ®µï¼šå¾åå°„è»¸ç•«ç·šåˆ°æ–°é»
                animateReflectionSecondPhase(originalPoint, newPoint, currentStep - halfSteps, halfSteps);
            }
        }
        
        // åå°„å‹•ç•«ç¬¬ä¸€éšæ®µ
        function animateReflectionFirstPhase(originalPoint, newPoint, currentStep, halfSteps) {
            // ç¢ºå®šåå°„è»¸
            let axisPoint = { x: 0, y: 0 };
            let distance = 0;
            
            if (newPoint.x === -originalPoint.x && newPoint.y === originalPoint.y) {
                // Yè»¸åå°„
                axisPoint = { x: 0, y: originalPoint.y };
                distance = Math.abs(originalPoint.x);
            } else if (newPoint.x === originalPoint.x && newPoint.y === -originalPoint.y) {
                // Xè»¸åå°„
                axisPoint = { x: originalPoint.x, y: 0 };
                distance = Math.abs(originalPoint.y);
            }
            
            // è¨ˆç®—ç•¶å‰ä½ç½®
            const progress = currentStep / halfSteps;
            const currentX = originalPoint.x + (axisPoint.x - originalPoint.x) * progress;
            const currentY = originalPoint.y + (axisPoint.y - originalPoint.y) * progress;
            
            // ç¹ªè£½å¾åŸé»åˆ°åå°„è»¸çš„ç·š
            const startPixel = coordToPixel(originalPoint.x, originalPoint.y);
            const currentPixel = coordToPixel(currentX, currentY);
            
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startPixel.x, startPixel.y);
            ctx.lineTo(currentPixel.x, currentPixel.y);
            ctx.stroke();
            
            // ç¹ªè£½å‹•ç•«ä¸­çš„é»ï¼ˆäº¤å‰ç¬¦è™Ÿï¼‰
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 3;
            const crossSize = 8;
            
            ctx.beginPath();
            ctx.moveTo(currentPixel.x - crossSize, currentPixel.y - crossSize);
            ctx.lineTo(currentPixel.x + crossSize, currentPixel.y + crossSize);
            ctx.moveTo(currentPixel.x + crossSize, currentPixel.y - crossSize);
            ctx.lineTo(currentPixel.x - crossSize, currentPixel.y + crossSize);
            ctx.stroke();
            
            // é¡¯ç¤ºè·é›¢
            if (currentStep === halfSteps) {
                const midPixel = coordToPixel((originalPoint.x + axisPoint.x) / 2, (originalPoint.y + axisPoint.y) / 2);
                ctx.fillStyle = '#333';
                ctx.font = '12px Arial';
                
                // åˆ¤æ–·æ˜¯å¦ç‚ºXè»¸åå°„
                const isXAxisReflection = (newPoint.x === originalPoint.x && newPoint.y === -originalPoint.y);
                
                if (isXAxisReflection) {
                    // Xè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„å·¦å´æˆ–å³å´
                    ctx.textAlign = originalPoint.x > 0 ? 'right' : 'left';
                    const offsetX = originalPoint.x > 0 ? -15 : 15;
                    ctx.fillText(`${distance}`, midPixel.x + offsetX, midPixel.y + 5);
                } else {
                    // Yè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„ä¸Šæ–¹
                    ctx.textAlign = 'center';
                    ctx.fillText(`${distance}`, midPixel.x, midPixel.y - 10);
                }
            }
        }
        
        // åå°„å‹•ç•«ç¬¬äºŒéšæ®µ
        function animateReflectionSecondPhase(originalPoint, newPoint, currentStep, halfSteps) {
            // ç¢ºå®šåå°„è»¸
            let axisPoint = { x: 0, y: 0 };
            let distance = 0;
            
            if (newPoint.x === -originalPoint.x && newPoint.y === originalPoint.y) {
                // Yè»¸åå°„
                axisPoint = { x: 0, y: originalPoint.y };
                distance = Math.abs(originalPoint.x);
            } else if (newPoint.x === originalPoint.x && newPoint.y === -originalPoint.y) {
                // Xè»¸åå°„
                axisPoint = { x: originalPoint.x, y: 0 };
                distance = Math.abs(originalPoint.y);
            }
            
            // ç¹ªè£½å®Œæ•´çš„ç¬¬ä¸€æ¢ç·šï¼ˆè—è‰²ï¼‰
            const startPixel = coordToPixel(originalPoint.x, originalPoint.y);
            const axisPixel = coordToPixel(axisPoint.x, axisPoint.y);
            
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startPixel.x, startPixel.y);
            ctx.lineTo(axisPixel.x, axisPixel.y);
            ctx.stroke();
            
            // è¨ˆç®—ç¬¬äºŒæ¢ç·šçš„ç•¶å‰ä½ç½®
            const progress = currentStep / halfSteps;
            const currentX = axisPoint.x + (newPoint.x - axisPoint.x) * progress;
            const currentY = axisPoint.y + (newPoint.y - axisPoint.y) * progress;
            const currentPixel = coordToPixel(currentX, currentY);
            
            // ç¹ªè£½å¾åå°„è»¸åˆ°æ–°é»çš„ç·šï¼ˆç´…è‰²ï¼‰
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(axisPixel.x, axisPixel.y);
            ctx.lineTo(currentPixel.x, currentPixel.y);
            ctx.stroke();
            
            // ç¹ªè£½å‹•ç•«ä¸­çš„é»ï¼ˆäº¤å‰ç¬¦è™Ÿï¼‰
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            const crossSize = 8;
            
            ctx.beginPath();
            ctx.moveTo(currentPixel.x - crossSize, currentPixel.y - crossSize);
            ctx.lineTo(currentPixel.x + crossSize, currentPixel.y + crossSize);
            ctx.moveTo(currentPixel.x + crossSize, currentPixel.y - crossSize);
            ctx.lineTo(currentPixel.x - crossSize, currentPixel.y + crossSize);
            ctx.stroke();
            
            // é¡¯ç¤ºå…©æ®µè·é›¢
            const midPixel1 = coordToPixel((originalPoint.x + axisPoint.x) / 2, (originalPoint.y + axisPoint.y) / 2);
            const midPixel2 = coordToPixel((axisPoint.x + currentX) / 2, (axisPoint.y + currentY) / 2);
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            
            // åˆ¤æ–·æ˜¯å¦ç‚ºXè»¸åå°„
            const isXAxisReflection = (newPoint.x === originalPoint.x && newPoint.y === -originalPoint.y);
            
            if (isXAxisReflection) {
                // Xè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„å·¦å´æˆ–å³å´
                ctx.textAlign = originalPoint.x > 0 ? 'right' : 'left';
                const offsetX = originalPoint.x > 0 ? -15 : 15;
                ctx.fillText(`${distance}`, midPixel1.x + offsetX, midPixel1.y + 5);
                ctx.fillText(`${distance}`, midPixel2.x + offsetX, midPixel2.y + 5);
            } else {
                // Yè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„ä¸Šæ–¹
                ctx.textAlign = 'center';
                ctx.fillText(`${distance}`, midPixel1.x, midPixel1.y - 10);
                ctx.fillText(`${distance}`, midPixel2.x, midPixel2.y - 10);
            }
        }
        
        // é¡¯ç¤ºåå°„åƒè€ƒç·šæ®µä¸¦é€æ¼¸æ·¡å‡º
        function showReflectionLinesWithFadeOut(originalPoint, newPoint) {
            const fadeSteps = 180; // 3ç§’æ·¡å‡º (60fps * 3ç§’ = 180æ­¥)
            let fadeStep = 0;
            
            function fadeAnimate() {
                if (fadeStep <= fadeSteps) {
                    // é‡ç¹ªç•«å¸ƒ
                    initCanvas();
                    
                    // è¨ˆç®—é€æ˜åº¦ (å¾1.0åˆ°0.0)
                    const alpha = Math.max(0, 1 - (fadeStep / fadeSteps));
                    
                    // ç¹ªè£½æ·¡å‡ºçš„åå°„åƒè€ƒç·šæ®µ
                    drawReflectionLinesWithAlpha(originalPoint, newPoint, alpha);
                    
                    fadeStep++;
                    requestAnimationFrame(fadeAnimate);
                } else {
                    // æ·¡å‡ºå®Œæˆï¼Œé‡ç¹ªä¹¾æ·¨çš„ç•«å¸ƒ
                    initCanvas();
                }
            }
            
            fadeAnimate();
        }
        
        // ç¹ªè£½å¸¶é€æ˜åº¦çš„åå°„åƒè€ƒç·šæ®µ
        function drawReflectionLinesWithAlpha(originalPoint, newPoint, alpha) {
            // ç¢ºå®šåå°„è»¸
            let axisPoint = { x: 0, y: 0 };
            let distance = 0;
            let isXAxisReflection = false;
            
            if (newPoint.x === -originalPoint.x && newPoint.y === originalPoint.y) {
                // Yè»¸åå°„
                axisPoint = { x: 0, y: originalPoint.y };
                distance = Math.abs(originalPoint.x);
                isXAxisReflection = false;
            } else if (newPoint.x === originalPoint.x && newPoint.y === -originalPoint.y) {
                // Xè»¸åå°„
                axisPoint = { x: originalPoint.x, y: 0 };
                distance = Math.abs(originalPoint.y);
                isXAxisReflection = true;
            }
            
            const startPixel = coordToPixel(originalPoint.x, originalPoint.y);
            const axisPixel = coordToPixel(axisPoint.x, axisPoint.y);
            const endPixel = coordToPixel(newPoint.x, newPoint.y);
            
            // è¨­ç½®å…¨å±€é€æ˜åº¦
            ctx.globalAlpha = alpha;
            
            // ç¹ªè£½ç¬¬ä¸€æ¢ç·šæ®µï¼ˆè—è‰²ï¼‰
            ctx.strokeStyle = '#4facfe';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(startPixel.x, startPixel.y);
            ctx.lineTo(axisPixel.x, axisPixel.y);
            ctx.stroke();
            
            // ç¹ªè£½ç¬¬äºŒæ¢ç·šæ®µï¼ˆç´…è‰²ï¼‰
            ctx.strokeStyle = '#ff6b6b';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(axisPixel.x, axisPixel.y);
            ctx.lineTo(endPixel.x, endPixel.y);
            ctx.stroke();
            
            // é¡¯ç¤ºè·é›¢æ¨™ç±¤
            const midPixel1 = coordToPixel((originalPoint.x + axisPoint.x) / 2, (originalPoint.y + axisPoint.y) / 2);
            const midPixel2 = coordToPixel((axisPoint.x + newPoint.x) / 2, (axisPoint.y + newPoint.y) / 2);
            
            ctx.fillStyle = '#333';
            ctx.font = '12px Arial';
            
            if (isXAxisReflection) {
                // Xè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„å·¦å´æˆ–å³å´
                ctx.textAlign = originalPoint.x > 0 ? 'right' : 'left';
                const offsetX = originalPoint.x > 0 ? -15 : 15;
                ctx.fillText(`${distance}`, midPixel1.x + offsetX, midPixel1.y + 5);
                ctx.fillText(`${distance}`, midPixel2.x + offsetX, midPixel2.y + 5);
            } else {
                // Yè»¸åå°„ï¼šæ¨™ç±¤æ”¾åœ¨ç·šæ®µçš„ä¸Šæ–¹
                ctx.textAlign = 'center';
                ctx.fillText(`${distance}`, midPixel1.x, midPixel1.y - 10);
                ctx.fillText(`${distance}`, midPixel2.x, midPixel2.y - 10);
            }
            
            // é‡ç½®é€æ˜åº¦
            ctx.globalAlpha = 1.0;
        }
        
        // åˆå§‹åŒ–
        window.onload = function() {
            initCanvas();
            updatePointsList();
        };
    </script>
</body>
</html>